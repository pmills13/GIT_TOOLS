# -*- coding: utf-8 -*-
"""
@author: pmills
"""

import os

def Create_SpaceClaim_File(currDir, case_path, CAD_dir):

  ## Create the output directories for spaceclaim to write to
  CFD_DIR = os.path.join(currDir, 'CFD')
  if not os.path.exists(CFD_DIR):
    os.mkdir(CFD_DIR)

  SC_OUTPUT_DIR = os.path.join(CFD_DIR, 'MESH_INPUTS')
  if not os.path.exists(SC_OUTPUT_DIR):
    os.mkdir(SC_OUTPUT_DIR)

  OUT_FILE = os.path.join(SC_OUTPUT_DIR, 'geometry_values.txt')
  if os.path.exists(OUT_FILE):
    os.remove(OUT_FILE)

  MESH_VARS_FILE = os.path.join(SC_OUTPUT_DIR, 'mesh_vars.txt')
  if os.path.exists(MESH_VARS_FILE):
    os.remove(MESH_VARS_FILE)

  MRP_FILE = os.path.join(SC_OUTPUT_DIR, 'Control_Surfaces_MRP_vars.txt')
  if os.path.exists(MRP_FILE):
    os.remove(MRP_FILE)

  ## create the spaceclaim file object
  if CAD_dir['found'] == False:
    SC_FILE = os.path.join(currDir, 'Extract_SpaceClaim_Geometries.py')
  else:
    SC_FILE = os.path.join(CAD_dir['path'], 'Extract_SpaceClaim_Geometries.py')
  if os.path.exists(SC_FILE):
    os.remove(SC_FILE)

  ## spaceclaim requires files to have double backslashes and be enclosed by ""
  case_path = '\"' + case_path.replace('\\','\\\\') + '\"'
  OUT_FILE = '\"' + OUT_FILE.replace('\\', '\\\\') + '\"'
  MESH_VARS_FILE = '\"' + MESH_VARS_FILE.replace('\\', '\\\\') + '\"'
  MRP_FILE = '\"' + MRP_FILE.replace('\\','\\\\') + '\"'


  with open(SC_FILE, 'w') as f:
    f.write('# Python Script, API Version = V242\n\n')
    f.write('from SpaceClaim.Api.V242 import *\n')
    f.write('from System import Array\n')
    f.write('from SpaceClaim.Api.V242.Geometry import IShape\n')
    f.write('from SpaceClaim.Api.V242.Geometry import Matrix, Frame\n')
    f.write('from SpaceClaim.Api.V242.Geometry import PointUV\n')
    f.write('import math\n\n')
    f.write('DocumentOpen.Execute(' + case_path + ')\n\n')
    f.write('doc = Window.ActiveWindow.Document\n')
    f.write('main_part = doc.MainPart\n\n')
    f.write('identity_matrix = Matrix.Identity\n\n')

    f.write('def createOutputFile():\n')
    f.write('\toutputFile = ' + OUT_FILE + '\n')
    f.write('\tfile = open(outputFile, \'w\')\n')
    f.write('\treturn(file)\n\n')

    f.write('def createOutputMeshFile():\n')
    f.write('\toutputFile = ' + MESH_VARS_FILE + '\n')
    f.write('\tfile = open(outputFile, \'w\')\n')
    f.write('\treturn(file)\n\n')

    f.write('def CreateOutputMRPFile():\n')
    f.write('\toutputFile = ' + MRP_FILE +'\n')
    f.write('\tfile = open(outputFile, \'w\')\n')
    f.write('\treturn(file)\n\n')

    f.write('fmesh = createOutputMeshFile()\n')

    f.write('for part in doc.Parts:\n')
    f.write('\tfor body in part.Bodies:\n')
    f.write('\t\tif \'boi\' in body.GetName().ToString().ToLower():\n')
    f.write('\t\t\tfmesh.write(\'Body_of_Influence:\\t\' + str(body.Name) + \'\\n\\n\')\n\n')

    f.write('interfaces = set()\n')
    f.write('splitInterfaces= {}\n')
    f.write('splitInterfaces[\'name\'] = \'\'\n')
    f.write('splitInterfaces[\'maxPoint\'] =  []\n')
    f.write('splitInterfaces[\'minPoint\'] = []\n')
    f.write('splitInterfaces[\'inner_diameter\'] = []\n')
    f.write('interfaceFound = False\n\n')

    f.write('for group in doc.MainPart.Groups:\n')
    f.write('\tif \'interface\' in group.Name:\n')
    f.write('\t\tinterfaceFound = True\n')
    f.write('\t\tif splitInterfaces[\'name\'] == \'\':\n')
    f.write('\t\t\tsplitInterfaces[\'name\'] = group.GetName().ToLower()\n')
    f.write('\t\telse:\n')
    f.write('\t\t\tif splitInterfaces[\'name\'] == group.GetName().ToLower():\n')
    f.write('\t\t\t\tdoNothing = True\n')
    f.write('\t\t\telse:\n')
    f.write('\t\t\t\tbodyMin = min(splitInterfaces[\'minPoint\'])\n')
    f.write('\t\t\t\tbodyMax = max(splitInterfaces[\'maxPoint\'])\n')
    f.write('\t\t\t\tbody_diam = math.sqrt((bodyMax - bodyMin)**2)\n')
    f.write('\t\t\t\tinterfaceName = str(splitInterfaces[\'name\']).replace(\'interface_prop_\',\'\')\n')
    f.write('\t\t\t\tID = min(splitInterfaces[\'inner_diameter\'])\n')
    f.write('\t\t\t\tinterfaces.add(tuple([interfaceName, body_diam, ID]))\n')
    f.write('\t\t\t\tsplitInterfaces[\'name\'] = group.GetName().ToLower()\n')
    f.write('\t\t\t\tsplitInterfaces[\'maxPoint\'] =  []\n')
    f.write('\t\t\t\tsplitInterfaces[\'minPoint\'] = []\n')
    f.write('\t\t\t\tsplitInterfaces[\'inner_diameter\'] = []\n\n')


    f.write('\t\tresult = Copy.Execute(FaceSelection.Create(group.Members))\n')
    f.write('\t\tfor part in doc.Parts:\n')
    f.write('\t\t\tfor body in part.Bodies:\n')
    f.write('\t\t\t\tif body.Name.ToString().ToLower() == \'surface\':\n')
    f.write('\t\t\t\t\tfor i_face in body.Faces:\n')
    f.write('\t\t\t\t\t\tfacePoints_max = set()\n')
    f.write('\t\t\t\t\t\tinnerDiam = []\n')
    f.write('\t\t\t\t\t\tfor i_loop in i_face.Shape.Loops:\n')
    f.write('\t\t\t\t\t\t\tfor i_edge in i_loop.Edges:\n')
    f.write('\t\t\t\t\t\t\t\tpt = i_edge.StartPoint\n')
    f.write('\t\t\t\t\t\t\t\tpt = [round(i,8) for i in [pt.X, pt.Y, pt.Z]]\n')
    f.write('\t\t\t\t\t\t\t\tfacePoints_max.add(tuple(pt))\n')
    f.write('\t\t\t\t\t\t\t\tpt2 = i_edge.EndPoint\n')
    f.write('\t\t\t\t\t\t\t\tpt2 = [round(i,8) for i in [pt2.X, pt2.Y, pt2.Z]]\n')
    f.write('\t\t\t\t\t\t\t\tfacePoints_max.add(tuple(pt2))\n')
    f.write('\t\t\t\t\t\t\t\tif pt[1] == 0.0 and pt2[1] == 0.0:\n')
    f.write('\t\t\t\t\t\t\t\t\tinnerDiam.append(math.sqrt((pt2[2] - pt[2])**2))\n')

    f.write('\t\t\t\t\t\tfacePoints_max = [list(i) for i in facePoints_max]\n')
    f.write('\t\t\t\t\t\tbody_point_max = max(p[2] for p in facePoints_max)\n')
    f.write('\t\t\t\t\t\tbody_point_min = min(p[2] for p in facePoints_max)\n')

    f.write('\t\t\t\t\t\tsplitInterfaces[\'maxPoint\'].append(body_point_max)\n')
    f.write('\t\t\t\t\t\tsplitInterfaces[\'minPoint\'].append(body_point_min)\n')
    f.write('\t\t\t\t\t\tif not len(innerDiam) == 0:\n')
    f.write('\t\t\t\t\t\t\tsplitInterfaces[\'inner_diameter\'].append(min(innerDiam))\n')


    f.write('\t\t\t\t\t\tselection = BodySelection.Create(body)\n')
    f.write('\t\t\t\t\t\tresult = Delete.Execute(selection)\n\n')

    f.write('if interfaceFound == True:\n')
    f.write('\tbodyMin = min(splitInterfaces[\'minPoint\'])\n')
    f.write('\tbodyMax = max(splitInterfaces[\'maxPoint\'])\n')
    f.write('\tbody_diam = math.sqrt((bodyMax - bodyMin)**2)\n')
    f.write('\tinterfaceName = str(splitInterfaces[\'name\']).replace(\'interface_prop_\',\'\')\n')
    f.write('\tID = min(splitInterfaces[\'inner_diameter\'])\n')
    f.write('\tinterfaces.add(tuple([interfaceName, body_diam, ID]))\n')

    f.write('\tinterfaces = [list(i_interface) for i_interface in interfaces]\n')
    f.write('\tfor i_int in range(len(interfaces)):\n')
    f.write('\t\tfmesh.write(\'INTERFACE:\\t\' + str(interfaces[i_int][0]) + \'\\n\')\n')
    f.write('\t\tfmesh.write(\'diameter:\\t\' + str(interfaces[i_int][1]) + \'\\n\')\n')
    f.write('\t\tfmesh.write(\'inner_diameter:\\t\' + str(interfaces[i_int][2]) + \'\\n\\n\')\n')
    f.write('else:\n')
    f.write('\tfmesh.write(\'No Interfaces found.\\n\')\n')
    f.write('fmesh.close()\n\n')

    f.write('names_to_exclude = [\'farfield\', \'interface\', \'outlet\', \'symmetry\']\n')
    f.write('goodNames = []\n')
    f.write('badNames = []\n')
    f.write('badAreas = []\n')
    f.write('BCs = NamedSelection.GetGroups()\n')
    f.write('for name in BCs:\n')
    f.write('\tbadNameFound = False\n')
    f.write('\tfor i_name in names_to_exclude:\n')
    f.write('\t\tif i_name in name.GetName().ToString().ToLower():\n')
    f.write('\t\t\tbadNameFound = True\n')
    f.write('\t\t\tbadNames.append(name.GetName().ToString())\n')
    f.write('\t\t\tbadFaces = FaceSelection.CreateByGroups(name.GetName().ToString()).Items\n')
    f.write('\t\t\tfor i_bad_face in badFaces:\n')
    f.write('\t\t\t\tbadAreas.append(round(i_bad_face.Area, 8))\n')
    f.write('\tif badNameFound == False:\n')
    f.write('\t\tgoodNames.append(name.GetName().ToString())\n\n')
    f.write('original_bodies = []\n')
    f.write('for i_body in main_part.Bodies:\n')
    f.write('\toriginal_bodies.append(i_body.Name)\n\n')
    f.write('original_enclosures = []\n')
    f.write('for part in doc.Parts:\n')
    f.write('\tfor body in part.Bodies:\n')
    f.write('\t\tif \'enclosure\' in part.Name.ToLower() or \'enclosure\' in body.Name.ToLower():\n')
    f.write('\t\t\toriginal_enclosures.append(body.Name)\n\n')

    f.write('bodyNames = []\n')
    f.write('bodyCheckNames = [\'body\', \'boattail\', \'boat_tail\']\n')
    f.write('for i_goodName in range(len(goodNames)):\n')
    f.write('\tif any(i_bodyName in goodNames[i_goodName] for i_bodyName in bodyCheckNames):\n')
    f.write('\t\tbodyNames.append(goodNames[i_goodName])\n')
    f.write('for i_bodyName in bodyNames:\n')
    f.write('\tgoodNames.remove(i_bodyName)\n')
    f.write('\tgoodNames.append(i_bodyName)\n\n')

    f.write('created_enclosures = []\n')
    f.write('created_physical_enclosures = []\n')
    f.write('for i_name in range(len(goodNames)):\n')
    f.write('\tselFaces = FaceSelection.CreateByGroups(goodNames[i_name])\n')
    f.write('\tresult = DetachFaces.Execute(selFaces)\n\n')
    f.write('\tnew_enclosures = []\n')
    f.write('\tnew_enclosures_names = []\n')
    f.write('\tfor part in doc.Parts:\n')
    f.write('\t\tfor body in part.Bodies:\n')
    f.write('\t\t\tnew_enclosures.append(body)\n')
    f.write('\t\t\tnew_enclosures_names.append(body.Name)\n\n')
    f.write('\tcount = 2\n')
    f.write('\tfor i_enclosure in new_enclosures:\n')
    f.write('\t\tif not i_enclosure.Name in original_bodies:\n')
    f.write('\t\t\tif not i_enclosure.Name in original_enclosures:\n')
    f.write('\t\t\t\tselection = Selection.Create(i_enclosure)\n')
    f.write('\t\t\t\tif \'CREATED_\' + str(goodNames[i_name]) in original_enclosures:\n')
    f.write('\t\t\t\t\tresult = RenameObject.Execute(selection, \'CREATED_\' + str(count) + \'_\' + goodNames[i_name])\n')
    f.write('\t\t\t\t\tcount += 1\n')
    f.write('\t\t\t\telse:\n')
    f.write('\t\t\t\t\tresult = RenameObject.Execute(selection, \'CREATED_\' + goodNames[i_name])\n\n')
    f.write('\t\t\t\tcurr_enclosure_faces = i_enclosure.Shape.Faces\n')
    f.write('\t\t\t\tbadFace_idx = []\n')
    f.write('\t\t\t\tfor i_face in curr_enclosure_faces:\n')
    f.write('\t\t\t\t\tif round(i_face.Area,8) in badAreas:\n')
    f.write('\t\t\t\t\t\tbadFace_idx.append(i_face)\n\n')
    f.write('\t\t\t\tisUpdateEnclosures = True\n')
    f.write('\t\t\t\tif not len(badFace_idx) == 0:\n')
    f.write('\t\t\t\t\tif len(badFace_idx) == len(curr_enclosure_faces):\n')
    f.write('\t\t\t\t\t\tresult = Delete.Execute(selection)\n')
    f.write('\t\t\t\t\t\tisUpdateEnclosures = False\n\n')
    f.write('\t\t\t\tif isUpdateEnclosures == True:\n')
    f.write('\t\t\t\t\tif count == 2:\n')
    f.write('\t\t\t\t\t\toriginal_enclosures.append(\'CREATED_\' + goodNames[i_name])\n')
    f.write('\t\t\t\t\t\tcreated_enclosures.append(\'CREATED_\' + goodNames[i_name])\n')
    f.write('\t\t\t\t\telse:\n')
    f.write('\t\t\t\t\t\toriginal_enclosures.append(\'CREATED_\' + str(count-1) + \'_\' + goodNames[i_name])\n')
    f.write('\t\t\t\t\t\tcreated_enclosures.append(\'CREATED_\' + str(count-1) + \'_\' + goodNames[i_name])\n')
    f.write('\t\t\t\t\tcreated_physical_enclosures.append(i_enclosure)\n\n')

    f.write('enclosures_to_delete = set()\n')
    f.write('final_enclosures = []\n')
    f.write('for i_enc in created_physical_enclosures:\n')
    f.write('\tarea = 0\n')
    f.write('\tfor i_face in i_enc.Shape.Faces:\n')
    f.write('\t\tarea += i_face.Area\n')
    f.write('\tarea = round(area,8)\n\n')
    f.write('\tbadAreaFound = False\n')
    f.write('\tfor i_area in badAreas:\n')
    f.write('\t\tif abs(i_area - area) <= 0.0000001:\n')
    f.write('\t\t\tbadAreaFound = True\n')
    f.write('\t\t\tenclosures_to_delete.add(i_enc)\n')
    f.write('\t\t\tbreak\n')
    f.write('\tif badAreaFound == False:\n')
    f.write('\t\tfinal_enclosures.append(i_enc)\n\n')
    f.write('for i in enclosures_to_delete:\n')
    f.write('\tselection = Selection.Create(i)\n')
    f.write('\tresult = Delete.Execute(selection)\n\n')


    f.write('def MeasureControlSurfaceGeometry(i_enclosure, LE_tip, fout):\n')
    f.write('\tmax_area = float(\'-inf\')\n')
    f.write('\tmax_area_face = \'\'\n')
    f.write('\tfor i_face in i_enclosure.Faces:\n')
    f.write('\t\tarea = i_face.Shape.Area\n')
    f.write('\t\tif area > max_area:\n')
    f.write('\t\t\tmax_area = area\n')
    f.write('\t\t\tmax_area_face = i_face\n\n')
    f.write('\tadjacentFaces = set()\n')
    f.write('\tbox = max_area_face.Shape.GetBoundingBox(identity_matrix)\n')
    f.write('\tadjacentFaces.add(tuple([max_area_face.Shape, box.MinCorner.X]))\n')
    f.write('\tfor i_edge in max_area_face.Shape.Edges:\n')
    f.write('\t\tfor i_adjFace in i_edge.Faces:\n')
    f.write('\t\t\tif i_adjFace is not max_area_face:\n')
    f.write('\t\t\t\tif isinstance(i_adjFace.Geometry, Plane):\n')
    f.write('\t\t\t\t\tbox = i_adjFace.GetBoundingBox(identity_matrix)\n')
    f.write('\t\t\t\t\tadjacentFaces.add(tuple([i_adjFace, box.MinCorner.X]))\n\n')
    f.write('\tadjacentFaces = [list(x) for x in adjacentFaces]\n')
    f.write('\tadjacentFaces = sorted(adjacentFaces, key = lambda x:(x[1]))\n\n')
    f.write('\tplanformArea = 0\n')
    f.write('\tfor i_face in adjacentFaces:\n')
    f.write('\t\tplanformArea += i_face[0].Area\n\n')
    f.write('\tfacePoints_min = set()\n')
    f.write('\tfor i_loop in adjacentFaces[0][0].Loops:\n')
    f.write('\t\tfor i_edge in i_loop.Edges:\n')
    f.write('\t\t\tpt = i_edge.StartPoint\n')
    f.write('\t\t\tpt = [round(i,8) for i in [pt.X, pt.Y, pt.Z]]\n')
    f.write('\t\t\tfacePoints_min.add(tuple(pt))\n')
    f.write('\t\t\tpt = i_edge.EndPoint\n')
    f.write('\t\t\tpt = [round(i,8) for i in [pt.X, pt.Y, pt.Z]]\n')
    f.write('\t\t\tfacePoints_min.add(tuple(pt))\n')
    f.write('\tfacePoints_min = [list(i) for i in facePoints_min]\n')
    f.write('\tmin_point_root =  sorted(facePoints_min, key = lambda x:(x[0]))[0]\n\n')
    f.write('\tif not abs(facePoints_min[2][0]) == abs(facePoints_min[2][-1]):\n')
    f.write('\t\tmax_y = max(abs(p[1]) for p in facePoints_min)\n')
    f.write('\t\ttop_points = [p for p in facePoints_min if abs(abs(p[1]) - max_y) <= 1e-2]\n')
    f.write('\t\tmin_point_tip = sorted(top_points, key = lambda x:(x[0]))[0]\n')
    f.write('\telse:\n')
    f.write('\t\tmax_y = max(abs(p[2]) for p in facePoints_min)\n')
    f.write('\t\ttop_points = [p for p in facePoints_min if abs(abs(p[2]) - max_y) <= 1e-2]\n')
    f.write('\t\tmin_point_tip = sorted(top_points, key = lambda x:(x[0]))[0]\n\n')
    f.write('\tfacePoints_max = set()\n')
    f.write('\tfor i_loop in adjacentFaces[-1][0].Loops:\n')
    f.write('\t\tfor i_edge in i_loop.Edges:\n')
    f.write('\t\t\tpt = i_edge.StartPoint\n')
    f.write('\t\t\tpt = [round(i,8) for i in [pt.X, pt.Y, pt.Z]]\n')
    f.write('\t\t\tfacePoints_max.add(tuple(pt))\n')
    f.write('\t\t\tpt = i_edge.EndPoint\n')
    f.write('\t\t\tpt = [round(i,8) for i in [pt.X, pt.Y, pt.Z]]\n')
    f.write('\t\t\tfacePoints_max.add(tuple(pt))\n\n')
    f.write('\tfacePoints_max = [list(i) for i in facePoints_max]\n')
    f.write('\troot_max_x = max(p[0] for p in facePoints_max)\n')
    f.write('\tright_points = [p for p in facePoints_max if abs(p[0] - root_max_x) <= 1e-2]\n')
    f.write('\tmax_point_root = sorted(right_points, key = lambda x:(abs(x[2])))[0]\n\n')
    f.write('\tif not abs(facePoints_min[2][0]) == abs(facePoints_min[2][-1]):\n')
    f.write('\t\tmax_y = max(abs(p[1]) for p in facePoints_max)\n')
    f.write('\t\ttop_points = [p for p in facePoints_max if abs(abs(p[1]) -max_y) <= 1e-2]\n')
    f.write('\t\tmax_point_tip = sorted(top_points, key = lambda x:(x[0]))[-1]\n')
    f.write('\telse:\n')
    f.write('\t\tmax_y = max(abs(p[2]) for p in facePoints_max)\n')
    f.write('\t\ttop_points = [p for p in facePoints_max if abs(abs(p[2]) -max_y) <= 1e-2]\n')
    f.write('\t\tmax_point_tip = sorted(top_points, key = lambda x:(x[0]))[-1]\n\n')
    f.write('\tif abs(min_point_root[2] - max_point_root[2]) <= 0.001:\n')
    f.write('\t\trootChord = math.sqrt((min_point_root[0] - max_point_root[0])**2)\n')
    f.write('\t\ttipChord = math.sqrt((max_point_tip[0] - min_point_tip[0])**2)\n')
    f.write('\telse:\n')
    f.write('\t\trootChord = math.sqrt((min_point_root[0] - max_point_root[0])**2 + (min_point_root[2] - max_point_root[2])**2)\n')
    f.write('\t\ttipChord = math.sqrt((max_point_tip[0] - min_point_tip[0])**2 + (max_point_tip[2] - min_point_tip[2])**2)\n\n')
    f.write('\tspan = math.sqrt( (max_point_root[0] - max_point_tip[0])**2 + (max_point_root[1] - max_point_tip[1])**2 + (max_point_root[2] - max_point_tip[2])**2)\n')
    f.write('\tangle_point = [min_point_root[0], min_point_tip[1], min_point_tip[2]]\n')
    f.write('\tvector_BA = [a-b for a,b in zip(angle_point, min_point_root)]\n')
    f.write('\tvector_BC = [c-b for c,b in zip(min_point_tip, min_point_root)]\n')
    f.write('\tdot_product = sum(a*b for a,b in zip(vector_BA, vector_BC))\n')
    f.write('\tmag_BA = math.sqrt(sum(a**2 for a in vector_BA))\n')
    f.write('\tmag_BC = math.sqrt(sum(b**2 for b in vector_BC))\n')
    f.write('\tcos_angle = dot_product / (mag_BA * mag_BC)\n')
    f.write('\tcos_angle = max(min(cos_angle, 1.0), -1.0)\n')
    f.write('\tangle_rad = math.acos(cos_angle)\n')
    f.write('\tangle_deg = round(math.degrees(angle_rad),1)\n')
    f.write('\tdistance_from_nose_to_LE = math.sqrt((min_point_root[0] - LE_tip)**2)\n')
    f.write('\tsurfName = i_enclosure.Name.ToLower().replace(\'created_wall_aero_\', \'\')[:-1]\n')
    f.write('\tfout.write(\'SURFACE:\\t\' + str(surfName) + \'\\n\')\n')
    f.write('\tfout.write(\'root_chord:\\t\' + str(rootChord) + \'\\n\')\n')
    f.write('\tfout.write(\'tip_chord:\\t\' + str(tipChord) + \'\\n\')\n')
    f.write('\tfout.write(\'span:\\t\' + str(span) + \'\\n\')\n')
    f.write('\tfout.write(\'LE_sweep_angle:\\t\' + str(angle_deg) + \'\\n\')\n')
    f.write('\tfout.write(\'LE_distance_from_nose:\\t\' + str(distance_from_nose_to_LE) + \'\\n\\n\')\n\n')

    f.write('def MeasureCowlSurfaceGeometry(i_enclosure, fout):\n')
    f.write('\tmaxPt = float(\'-inf\')\n')
    f.write('\tmaxFace = \'\'\n')
    f.write('\tfor i_face in i_enclosure.Faces:\n')
    f.write('\t\tfor i_loop in i_face.Shape.Loops:\n')
    f.write('\t\t\tfor i_edge in i_loop.Edges:\n')
    f.write('\t\t\t\tpt = i_edge.StartPoint\n')
    f.write('\t\t\t\tpt = [round(i,8) for i in [pt.X, pt.Y, pt.Z]]\n')
    f.write('\t\t\t\tif pt[0] > maxPt:\n')
    f.write('\t\t\t\t\tmaxFace = i_face\n')
    f.write('\t\t\t\tpt = i_edge.EndPoint\n')
    f.write('\t\t\t\tpt = [round(i,8) for i in [pt.X, pt.Y, pt.Z]]\n')
    f.write('\t\t\t\tif pt[0] > maxPt:\n')
    f.write('\t\t\t\t\tmaxFace = i_face\n\n')
    f.write('\tinnerPoint = float(\'inf\')\n')
    f.write('\tmeasurePT = \'\'\n')
    f.write('\tfor i_loop in maxFace.Shape.Loops:\n')
    f.write('\t\tfor i_edge in i_loop.Edges:\n')
    f.write('\t\t\tpt = i_edge.StartPoint\n')
    f.write('\t\t\tpt = [round(i,8) for i in [pt.X, pt.Y, pt.Z]]\n')
    f.write('\t\t\tif pt[1] == 0.0 and pt[2] >= 0.0:\n')
    f.write('\t\t\t\tif pt[0] < innerPoint:\n')
    f.write('\t\t\t\t\tmeasurePT = pt\n')
    f.write('\t\t\tpt = i_edge.EndPoint\n')
    f.write('\t\t\tpt = [round(i,8) for i in [pt.X, pt.Y, pt.Z]]\n')
    f.write('\t\t\tif pt[1] == 0.0 and pt[2] >= 0.0:\n')
    f.write('\t\t\t\tif pt[0] < innerPoint:\n')
    f.write('\t\t\t\t\tmeasurePT = pt\n\n')
    f.write('\tAref = math.pi * measurePT[2]**2\n')
    f.write('\tfout.write(\'Aref(m^2):\t\' + str(Aref) + \'\\n\')\n\n')


    f.write('def MeasureBodyGeometry(i_enclosure, LE_tip, base, fout):\n')
    f.write('\tmax_area = float(\'-inf\')\n')
    f.write('\tmax_area_face = \'\'\n')
    f.write('\tfor i_face in i_enclosure.Faces:\n')
    f.write('\t\tarea = i_face.Shape.Area\n')
    f.write('\t\tif area > max_area:\n')
    f.write('\t\t\tmax_area = area\n')
    f.write('\t\t\tmax_area_face = i_face\n\n')
    f.write('\tfacePoints_max = set()\n')
    f.write('\tfor i_loop in max_area_face.Shape.Loops:\n')
    f.write('\t\tfor i_edge in i_loop.Edges:\n')
    f.write('\t\t\tpt = i_edge.StartPoint\n')
    f.write('\t\t\tpt = [round(i,8) for i in [pt.X, pt.Y, pt.Z]]\n')
    f.write('\t\t\tfacePoints_max.add(tuple(pt))\n')
    f.write('\t\t\tpt = i_edge.EndPoint\n')
    f.write('\t\t\tpt = [round(i,8) for i in [pt.X, pt.Y, pt.Z]]\n')
    f.write('\t\t\tfacePoints_max.add(tuple(pt))\n')
    f.write('\tfacePoints_max = [list(i) for i in facePoints_max]\n')
    f.write('\tbody_point_max = max(p[2] for p in facePoints_max)\n')
    f.write('\tbody_point_min = min(p[2] for p in facePoints_max)\n')
    f.write('\tif abs(body_point_max) > abs(body_point_min):\n')
    f.write('\t\tbody_diam = body_point_max*2\n')
    f.write('\telse:\n')
    f.write('\t\tbody_diam = abs(body_point_min)*2\n')
    f.write('\tsurfName = i_enclosure.Name.ToLower().replace(\'created_wall_aero_\', \'\')\n')
    f.write('\tfout.write(\'SURFACE:\\t\' + str(surfName) + \'\\n\')\n')
    f.write('\tfout.write(\'body_diamater:\\t\' + str(body_diam) + \'\\n\')\n\n')
    f.write('\tif base == False:\n')
    f.write('\t\tmax_body_x = float(\'-inf\')\n')
    f.write('\t\tfor i_face in i_enclosure.Faces:\n')
    f.write('\t\t\tfor i_loop in i_face.Shape.Loops:\n')
    f.write('\t\t\t\tfor i_edge in i_loop.Edges:\n')
    f.write('\t\t\t\t\tpt = i_edge.StartPoint\n')
    f.write('\t\t\t\t\tpt = [round(i,8) for i in [pt.X, pt.Y, pt.Z]]\n')
    f.write('\t\t\t\t\tif pt[0] > max_body_x:\n')
    f.write('\t\t\t\t\t\tmax_body_x = pt[0]\n')
    f.write('\t\t\t\t\tpt2 = i_edge.StartPoint\n')
    f.write('\t\t\t\t\tpt2 = [round(i,8) for i in [pt2.X, pt2.Y, pt2.Z]]\n')
    f.write('\t\t\t\t\tif pt2[0] > max_body_x:\n')
    f.write('\t\t\t\t\t\tmax_body_x = pt2[0]\n')
    f.write('\t\tbody_len = math.sqrt((max_body_x - LE_tip)**2)\n')
    f.write('\telse:\n')
    f.write('\t\tmax_base_x = float(\'-inf\')\n')
    f.write('\t\tfor i_face in base.Faces:\n')
    f.write('\t\t\tfor i_loop in i_face.Shape.Loops:\n')
    f.write('\t\t\t\tfor i_edge in i_loop.Edges:\n')
    f.write('\t\t\t\t\tpt = i_edge.StartPoint\n')
    f.write('\t\t\t\t\tpt = [round(i,8) for i in [pt.X, pt.Y, pt.Z]]\n')
    f.write('\t\t\t\t\tif pt[0] > max_base_x:\n')
    f.write('\t\t\t\t\t\tmax_base_x = pt[0]\n')
    f.write('\t\t\t\t\tpt2 = i_edge.StartPoint\n')
    f.write('\t\t\t\t\tpt2 = [round(i,8) for i in [pt2.X, pt2.Y, pt2.Z]]\n')
    f.write('\t\t\t\t\tif pt2[0] > max_base_x:\n')
    f.write('\t\t\t\t\t\tmax_base_x = pt2[0]\n')
    f.write('\t\tbody_len = math.sqrt((max_base_x - LE_tip)**2)\n')
    f.write('\tfout.write(\'body_length:\\t\' + str(body_len) + \'\\n\')\n\n')


    f.write('noseNames = [\'nose\', \'ramps\', \'spike\', \'aerospike\']\n')
    f.write('noseFound = False\n')
    f.write('for i_enclosure in final_enclosures:\n')
    f.write('\tif any(i_name in i_enclosure.Name.ToLower() for i_name in noseNames):\n')
    f.write('\t\tLE_tip = float(\'inf\')\n')
    f.write('\t\tfor i_face in i_enclosure.Faces:\n')
    f.write('\t\t\tfor i_loop in i_face.Shape.Loops:\n')
    f.write('\t\t\t\tfor i_edge in i_loop.Edges:\n')
    f.write('\t\t\t\t\tpt = i_edge.StartPoint\n')
    f.write('\t\t\t\t\tpt = [round(i,8) for i in [pt.X, pt.Y, pt.Z]]\n')
    f.write('\t\t\t\t\tif pt[0] < LE_tip:\n')
    f.write('\t\t\t\t\t\tLE_tip = pt[0]\n')
    f.write('\t\t\t\t\tpt2 = i_edge.StartPoint\n')
    f.write('\t\t\t\t\tpt2 = [round(i,8) for i in [pt2.X, pt2.Y, pt2.Z]]\n')
    f.write('\t\t\t\t\tif pt2[0] < LE_tip:\n')
    f.write('\t\t\t\t\t\tLE_tip = pt2[0]\n')
    f.write('\t\tnoseFound = True\n')
    f.write('\t\tbreak\n\n')
    f.write('if noseFound == False:\n')
    f.write('\tfor i_enclosure in final_enclosures:\n')
    f.write('\t\tif \'body\' in i_enclosure.Name.ToLower():\n')
    f.write('\t\t\tLE_tip = float(\'inf\')\n')
    f.write('\t\t\tfor i_face in i_enclosure.Faces:\n')
    f.write('\t\t\t\tfor i_loop in i_face.Shape.Loops:\n')
    f.write('\t\t\t\t\tfor i_edge in i_loop.Edges:\n')
    f.write('\t\t\t\t\t\tpt = i_edge.EndPoint\n')
    f.write('\t\t\t\t\t\tpt = [round(i,8) for i in [pt.X, pt.Y, pt.Z]]\n')
    f.write('\t\t\t\t\t\tif pt[0] < LE_tip:\n')
    f.write('\t\t\t\t\t\t\tLE_tip = pt[0]\n')
    f.write('\t\t\t\t\t\tpt2 = i_edge.EndPoint\n')
    f.write('\t\t\t\t\t\tpt2 = [round(i,8) for i in [pt2.X, pt2.Y, pt2.Z]]\n')
    f.write('\t\t\t\t\t\tif pt2[0] < LE_tip:\n')
    f.write('\t\t\t\t\t\t\tLE_tip = pt2[0]\n\n')

    f.write('base = False\n')
    f.write('for i_enclosure in final_enclosures:\n')
    f.write('\tif \'base\' in i_enclosure.Name.ToLower():\n')
    f.write('\t\tbase  = i_enclosure\n')
    f.write('\t\tbreak\n\n\n')


    f.write('finFound = False\n')
    f.write('bodyFound = False\n')
    f.write('canardFound = False\n')
    f.write('strakeFound = False\n')
    f.write('fout = createOutputFile()\n')
    f.write('for i_enclosure in final_enclosures:\n')
    f.write('\ttry:\n')
    f.write('\t\tif len(i_enclosure) > 1:\n')
    f.write('\t\t\tmin_x = min_y = min_z = float(\'inf\')\n')
    f.write('\t\t\tmax_x = max_y = max_z = float(\'-inf\')\n')
    f.write('\t\t\tfor split in i_enclosure:\n')
    f.write('\t\t\t\tbox = split.Shape.GetBoundingBox(identity_matrix)\n')
    f.write('\t\t\t\tmin_x = min(min_x, box.MinCorner.X)\n')
    f.write('\t\t\t\tmin_y = min(min_y, box.MinCorner.Y)\n')
    f.write('\t\t\t\tmin_z = min(min_z, box.MinCorner.Z)\n')
    f.write('\t\t\t\tmax_x = max(max_x, box.MaxCorner.X)\n')
    f.write('\t\t\t\tmax_y = max(max_y, box.MaxCorner.Y)\n')
    f.write('\t\t\t\tmax_z = max(max_z, box.MaxCorner.Z)\n')
    f.write('\t\t\tlength_x = max_x - min_x\n')
    f.write('\t\t\tlength_y = max_y - min_y\n')
    f.write('\t\t\tlength_z = max_z - min_z\n\n')
    f.write('\texcept TypeError:\n')
    f.write('\t\tif bodyFound == False:\n')
    f.write('\t\t\tbodyNames = [\'body\']\n')
    f.write('\t\t\tif any(i_name in i_enclosure.Name.ToLower() for i_name in bodyNames):\n')
    f.write('\t\t\t\tbodyFound = True\n')
    f.write('\t\t\t\tMeasureBodyGeometry(i_enclosure, LE_tip, base, fout)\n')
    f.write('\t\tif canardFound == False:\n')
    f.write('\t\t\tcanardNames = [\'canard\']\n')
    f.write('\t\t\tif any(i_name in i_enclosure.Name.ToLower() for i_name in canardNames):\n')
    f.write('\t\t\t\tcanardFound = True\n')
    f.write('\t\t\t\tMeasureControlSurfaceGeometry(i_enclosure, LE_tip, fout)\n')
    f.write('\t\tif finFound == False:\n')
    f.write('\t\t\tfinNames = [\'fin\', \'tailfin\']\n')
    f.write('\t\t\tif any(i_name in i_enclosure.Name.ToLower() for i_name in finNames):\n')
    f.write('\t\t\t\tfinFound = True\n')
    f.write('\t\t\t\tMeasureControlSurfaceGeometry(i_enclosure, LE_tip, fout)\n\n')
    f.write('\t\tif strakeFound == False:\n')
    f.write('\t\t\tstrakeNames = [\'strake\']\n')
    f.write('\t\t\tif any(i_name in i_enclosure.Name.ToLower() for i_name in strakeNames):\n')
    f.write('\t\t\t\tstrakeFound = True\n')
    f.write('\t\t\t\tMeasureControlSurfaceGeometry(i_enclosure, LE_tip, fout)\n\n')

    f.write('cowlNames = [\'cowl_lip\']\n')
    f.write('for i_enclosure in final_enclosures:\n')
    f.write('\tif any(i_name in i_enclosure.Name.ToLower() for i_name in cowlNames):\n')
    f.write('\t\tMeasureCowlSurfaceGeometry(i_enclosure, fout)\n')
    f.write('\t\tbreak\n')

    f.write('fout.close()\n\n')


    f.write('def Calculate_Midpoint(pt1, pt2):\n')
    f.write('\tmidpoint = [((pt1[0] + pt2[0])/2), ((pt1[1] + pt2[1])/2), ((pt1[2] + pt2[2])/2)]\n')
    f.write('\treturn(midpoint)\n\n')

    f.write('def Calculate_Control_Surface_MRP(f, enclosure):\n')
    f.write('\tmax_area = float(\'-inf\')\n')
    f.write('\tmax_area_face = \'\'\n')
    f.write('\tnormal_faces = []\n')
    f.write('\tfor i_face in i_enclosure.Faces:\n')
    f.write('\t\tarea = i_face.Shape.Area\n')
    f.write('\t\tif area > max_area:\n')
    f.write('\t\t\tmax_area = area\n')
    f.write('\t\t\tmax_area_face = i_face\n\n')
    f.write('\twidth_faces = []\n')
    f.write('\tfor i_face in i_enclosure.Faces:\n')
    f.write('\t\tarea = i_face.Shape.Area\n')
    f.write('\t\tif abs(area - max_area) <= 0.0001:\n')
    f.write('\t\t\twidth_faces.append(i_face)\n')
    f.write('\t\t\tnormal_faces.append(i_face.Shape)\n\n')
    f.write('\tadjacentFaces = set()\n')
    f.write('\tmax_area_face = width_faces[0]\n')
    f.write('\tbox = max_area_face.Shape.GetBoundingBox(identity_matrix)\n')
    f.write('\tadjacentFaces.add(tuple([max_area_face.Shape, box.MinCorner.X]))\n')
    f.write('\tfor i_edge in max_area_face.Shape.Edges:\n')
    f.write('\t\tfor i_adjFace in i_edge.Faces:\n')
    f.write('\t\t\tif i_adjFace is not max_area_face:\n')
    f.write('\t\t\t\tif isinstance(i_adjFace.Geometry, Plane):\n')
    f.write('\t\t\t\t\tbox = i_adjFace.GetBoundingBox(identity_matrix)\n')
    f.write('\t\t\t\t\tadjacentFaces.add(tuple([i_adjFace, box.MinCorner.X]))\n\n')
    f.write('\tadjacentFaces = [list(x) for x in adjacentFaces]\n')
    f.write('\tadjacentFaces = sorted(adjacentFaces, key = lambda x:(x[1]))\n')
    f.write('\tfacePoints_min_A = set()\n')
    f.write('\tfor i_loop in adjacentFaces[0][0].Loops:\n')
    f.write('\t\tfor i_edge in i_loop.Edges:\n')
    f.write('\t\t\tpt = i_edge.StartPoint\n')
    f.write('\t\t\tpt = [round(i,8) for i in [pt.X, pt.Y, pt.Z]]\n')
    f.write('\t\t\tfacePoints_min_A.add(tuple(pt))\n')
    f.write('\t\t\tpt = i_edge.EndPoint\n')
    f.write('\t\t\tpt = [round(i,8) for i in [pt.X, pt.Y, pt.Z]]\n')
    f.write('\t\t\tfacePoints_min_A.add(tuple(pt))\n')
    f.write('\tfacePoints_min_A = [list(i) for i in facePoints_min_A]\n')
    f.write('\tmin_point_root_A =  sorted(facePoints_min_A, key = lambda x:(x[0]))[0]\n\n')
    f.write('\tif not abs(facePoints_min_A[2][0]) == abs(facePoints_min_A[2][-1]):\n')
    f.write('\t\tmax_y = max(abs(p[1]) for p in facePoints_min_A)\n')
    f.write('\t\ttop_points = [p for p in facePoints_min_A if abs(abs(p[1]) - max_y) <= 1e-2]\n')
    f.write('\t\tmin_point_tip_A = sorted(top_points, key = lambda x:(x[0]))[0]\n')
    f.write('\telse:\n')
    f.write('\t\tmax_y = max(abs(p[2]) for p in facePoints_min_A)\n')
    f.write('\t\ttop_points = [p for p in facePoints_min_A if abs(abs(p[2]) - max_y) <= 1e-2]\n')
    f.write('\t\tmin_point_tip_A = sorted(top_points, key = lambda x:(x[0]))[0]\n')
    f.write('\tfacePoints_max_A = set()\n')
    f.write('\tfor i_loop in adjacentFaces[-1][0].Loops:\n')
    f.write('\t\tfor i_edge in i_loop.Edges:\n')
    f.write('\t\t\tpt = i_edge.StartPoint\n')
    f.write('\t\t\tpt = [round(i,8) for i in [pt.X, pt.Y, pt.Z]]\n')
    f.write('\t\t\tfacePoints_max_A.add(tuple(pt))\n')
    f.write('\t\t\tpt = i_edge.EndPoint\n')
    f.write('\t\t\tpt = [round(i,8) for i in [pt.X, pt.Y, pt.Z]]\n')
    f.write('\t\t\tfacePoints_max_A.add(tuple(pt))\n\n')
    f.write('\tfacePoints_max_A = [list(i) for i in facePoints_max_A]\n')
    f.write('\troot_max_x = max(p[0] for p in facePoints_max_A)\n')
    f.write('\tright_points = [p for p in facePoints_max_A if abs(p[0] - root_max_x) <= 1e-2]\n')
    f.write('\tmax_point_root_A = sorted(right_points, key = lambda x:(abs(x[2])))[0]\n')
    f.write('\tif not abs(facePoints_min_A[2][0]) == abs(facePoints_min_A[2][-1]):\n')
    f.write('\t\tmax_y = max(abs(p[1]) for p in facePoints_max_A)\n')
    f.write('\t\ttop_points = [p for p in facePoints_max_A if abs(abs(p[1]) -max_y) <= 1e-2]\n')
    f.write('\t\tmax_point_tip_A = sorted(top_points, key = lambda x:(x[0]))[-1]\n')
    f.write('\telse:\n')
    f.write('\t\tmax_y = max(abs(p[2]) for p in facePoints_max_A)\n')
    f.write('\t\ttop_points = [p for p in facePoints_max_A if abs(abs(p[2]) -max_y) <= 1e-2]\n')
    f.write('\t\tmax_point_tip_A = sorted(top_points, key = lambda x:(x[0]))[-1]\n\n')
    f.write('\tadjacentFaces = set()\n')
    f.write('\tmax_Area_face = width_faces[-1]\n')
    f.write('\tbox = max_Area_face.Shape.GetBoundingBox(identity_matrix)\n')
    f.write('\tadjacentFaces.add(tuple([max_Area_face.Shape, box.MinCorner.X]))\n')
    f.write('\tfor i_edge in max_Area_face.Shape.Edges:\n')
    f.write('\t\tfor i_BdjFace in i_edge.Faces:\n')
    f.write('\t\t\tif i_BdjFace is not max_Area_face:\n')
    f.write('\t\t\t\tif isinstance(i_BdjFace.Geometry, Plane):\n')
    f.write('\t\t\t\t\tbox = i_BdjFace.GetBoundingBox(identity_matrix)\n')
    f.write('\t\t\t\t\tadjacentFaces.add(tuple([i_BdjFace, box.MinCorner.X]))\n\n')
    f.write('\tadjacentFaces = [list(x) for x in adjacentFaces]\n')
    f.write('\tadjacentFaces = sorted(adjacentFaces, key = lambda x:(x[1]))\n')
    f.write('\tfacePoints_min_B = set()\n')
    f.write('\tfor i_loop in adjacentFaces[0][0].Loops:\n')
    f.write('\t\tfor i_edge in i_loop.Edges:\n')
    f.write('\t\t\tpt = i_edge.StartPoint\n')
    f.write('\t\t\tpt = [round(i,8) for i in [pt.X, pt.Y, pt.Z]]\n')
    f.write('\t\t\tfacePoints_min_B.add(tuple(pt))\n')
    f.write('\t\t\tpt = i_edge.EndPoint\n')
    f.write('\t\t\tpt = [round(i,8) for i in [pt.X, pt.Y, pt.Z]]\n')
    f.write('\t\t\tfacePoints_min_B.add(tuple(pt))\n')
    f.write('\tfacePoints_min_B = [list(i) for i in facePoints_min_B]\n')
    f.write('\tmin_point_root_B =  sorted(facePoints_min_B, key = lambda x:(x[0]))[0]\n')
    f.write('\tif not abs(facePoints_min_B[2][0]) == abs(facePoints_min_B[2][-1]):\n')
    f.write('\t\tmax_y = max(abs(p[1]) for p in facePoints_min_B)\n')
    f.write('\t\ttop_points = [p for p in facePoints_min_B if abs(abs(p[1]) - max_y) <= 1e-2]\n')
    f.write('\t\tmin_point_tip_B = sorted(top_points, key = lambda x:(x[0]))[0]\n')
    f.write('\telse:\n')
    f.write('\t\tmax_y = max(abs(p[2]) for p in facePoints_min_B)\n')
    f.write('\t\ttop_points = [p for p in facePoints_min_B if abs(abs(p[2]) - max_y) <= 1e-2]\n')
    f.write('\t\tmin_point_tip_B = sorted(top_points, key = lambda x:(x[0]))[0]\n\n')
    f.write('\tfacePoints_max_B = set()\n')
    f.write('\tfor i_loop in adjacentFaces[-1][0].Loops:\n')
    f.write('\t\tfor i_edge in i_loop.Edges:\n')
    f.write('\t\t\tpt = i_edge.StartPoint\n')
    f.write('\t\t\tpt = [round(i,8) for i in [pt.X, pt.Y, pt.Z]]\n')
    f.write('\t\t\tfacePoints_max_B.add(tuple(pt))\n')
    f.write('\t\t\tpt = i_edge.EndPoint\n')
    f.write('\t\t\tpt = [round(i,8) for i in [pt.X, pt.Y, pt.Z]]\n')
    f.write('\t\t\tfacePoints_max_B.add(tuple(pt))\n\n')
    f.write('\tfacePoints_max_B = [list(i) for i in facePoints_max_B]\n')
    f.write('\troot_max_x = max(p[0] for p in facePoints_max_B)\n')
    f.write('\tright_points = [p for p in facePoints_max_B if abs(p[0] - root_max_x) <= 1e-2]\n')
    f.write('\tmax_point_root_B = sorted(right_points, key = lambda x:(abs(x[2])))[0]\n\n')
    f.write('\tif not abs(facePoints_min_B[2][0]) == abs(facePoints_min_B[2][-1]):\n')
    f.write('\t\tmax_y = max(abs(p[1]) for p in facePoints_max_B)\n')
    f.write('\t\ttop_points = [p for p in facePoints_max_B if abs(abs(p[1]) -max_y) <= 1e-2]\n')
    f.write('\t\tmax_point_tip_B = sorted(top_points, key = lambda x:(x[0]))[-1]\n')
    f.write('\telse:\n')
    f.write('\t\tmax_y = max(abs(p[2]) for p in facePoints_max_B)\n')
    f.write('\t\ttop_points = [p for p in facePoints_max_B if abs(abs(p[2]) -max_y) <= 1e-2]\n')
    f.write('\t\tmax_point_tip_B = sorted(top_points, key = lambda x:(x[0]))[-1]\n\n')
    f.write('\tmid_A = Calculate_Midpoint(min_point_root_A, max_point_root_A)\n')
    f.write('\tmid_B = Calculate_Midpoint(min_point_root_B, max_point_root_B)\n')
    f.write('\tmrp_x = Calculate_Midpoint([mid_A[0],0,0], [mid_B[0],0,0])\n')
    f.write('\tmrp_y = Calculate_Midpoint([0,mid_A[1],0], [0,mid_B[1],0])\n')
    f.write('\tmrp_z = Calculate_Midpoint([0,0,mid_A[2]], [0,0,mid_B[2]])\n')
    f.write('\tenclosureName = enclosure.Name.replace(\'CREATED_wall_aero_\', \'\')\n')
    f.write('\tf.write(\'SURFACE:\\t\' + str(enclosureName) + \'\\n\')\n')
    f.write('\tf.write(\'MRP: \' + str(mrp_x[0]) + \' \' + str(mrp_y[1]) + \' \' + str(mrp_z[2]) + \'\\n\')\n\n')

    f.write('\tfacePoints_max1 = set()\n')
    f.write('\tfor i_loop in normal_faces[0].Loops:\n')
    f.write('\t\tfor i_edge in i_loop.Edges:\n')
    f.write('\t\t\tpt = i_edge.StartPoint\n')
    f.write('\t\t\tpt = [round(i,8) for i in [pt.X, pt.Y, pt.Z]]\n')
    f.write('\t\t\tfacePoints_max1.add(tuple(pt))\n')
    f.write('\t\t\tpt = i_edge.EndPoint\n')
    f.write('\t\t\tpt = [round(i,8) for i in [pt.X, pt.Y, pt.Z]]\n')
    f.write('\t\t\tfacePoints_max1.add(tuple(pt))\n')
    f.write('\tfacePoints_max1 = [list(i) for i in facePoints_max1]\n')
    f.write('\ttip_max_y1 = max(p[1] for p in facePoints_max1)\n')
    f.write('\ttip_max_z1 = max(p[2] for p in facePoints_max1)\n\n')
    f.write('\tfacePoints_max2 = set()\n')
    f.write('\tfor i_loop in normal_faces[-1].Loops:\n')
    f.write('\t\tfor i_edge in i_loop.Edges:\n')
    f.write('\t\t\tpt = i_edge.StartPoint\n')
    f.write('\t\t\tpt = [round(i,8) for i in [pt.X, pt.Y, pt.Z]]\n')
    f.write('\t\t\tfacePoints_max2.add(tuple(pt))\n')
    f.write('\t\t\tpt = i_edge.EndPoint\n')
    f.write('\t\t\tpt = [round(i,8) for i in [pt.X, pt.Y, pt.Z]]\n')
    f.write('\t\t\tfacePoints_max2.add(tuple(pt))\n')
    f.write('\tfacePoints_max2 = [list(i) for i in facePoints_max2]\n')
    f.write('\ttip_max_y2 = max(p[1] for p in facePoints_max2)\n')
    f.write('\ttip_max_z2 = max(p[2] for p in facePoints_max2)\n\n')
    f.write('\tif \'fin\' in enclosure.Name or \'canard\' in enclosure.Name:\n')
    f.write('\t\tif \'1\' in enclosure.Name or \'4\' in enclosure.Name:\n')
    f.write('\t\t\tif tip_max_y1 > tip_max_y2:\n')
    f.write('\t\t\t\ttipPoints_normal = sorted(facePoints_max1, key = lambda x:(abs(x[2])), reverse=True)[0:2]\n')
    f.write('\t\t\t\ttipPoints_normal_sorted = sorted(tipPoints_normal, key = lambda x:(x[0]))\n')
    f.write('\t\t\telse:\n')
    f.write('\t\t\t\ttipPoints_normal = sorted(facePoints_max2, key = lambda x:(abs(x[2])), reverse=True)[0:2]\n')
    f.write('\t\t\t\ttipPoints_normal_sorted = sorted(tipPoints_normal, key = lambda x:(x[0]))\n')
    f.write('\t\telif \'2\' in enclosure.Name or \'3\' in enclosure.Name:\n')
    f.write('\t\t\tif tip_max_y1 < tip_max_y2:\n')
    f.write('\t\t\t\ttipPoints_normal = sorted(facePoints_max1, key = lambda x:(abs(x[2])), reverse=True)[0:2]\n')
    f.write('\t\t\t\ttipPoints_normal_sorted = sorted(tipPoints_normal, key = lambda x:(x[0]))\n')
    f.write('\t\t\telse:\n')
    f.write('\t\t\t\ttipPoints_normal = sorted(facePoints_max2, key = lambda x:(abs(x[2])), reverse=True)[0:2]\n')
    f.write('\t\t\t\ttipPoints_normal_sorted = sorted(tipPoints_normal, key = lambda x:(x[0]))\n')
    f.write('\telif \'strake\' in enclosure.Name:\n')
    f.write('\t\tif \'1\' in enclosure.Name:\n')
    f.write('\t\t\tif tip_max_z1 < tip_max_z2:\n')
    f.write('\t\t\t\ttipPoints_normal = sorted(facePoints_max1, key = lambda x:(abs(x[2])), reverse=True)[0:2]\n')
    f.write('\t\t\t\ttipPoints_normal_sorted = sorted(tipPoints_normal, key = lambda x:(x[0]))\n')
    f.write('\t\t\telse:\n')
    f.write('\t\t\t\ttipPoints_normal = sorted(facePoints_max2, key = lambda x:(abs(x[2])), reverse=True)[0:2]\n')
    f.write('\t\t\t\ttipPoints_normal_sorted = sorted(tipPoints_normal, key = lambda x:(x[0]))\n')
    f.write('\t\telif \'2\' in enclosure.Name:\n')
    f.write('\t\t\tif tip_max_z1 > tip_max_z2:\n')
    f.write('\t\t\t\ttipPoints_normal = sorted(facePoints_max1, key = lambda x:(abs(x[2])), reverse=True)[0:2]\n')
    f.write('\t\t\t\ttipPoints_normal_sorted = sorted(tipPoints_normal, key = lambda x:(x[0]))\n')
    f.write('\t\t\telse:\n')
    f.write('\t\t\t\ttipPoints_normal = sorted(facePoints_max2, key = lambda x:(abs(x[2])), reverse=True)[0:2]\n')
    f.write('\t\t\t\ttipPoints_normal_sorted = sorted(tipPoints_normal, key = lambda x:(x[0]))\n')
    f.write('\tmin_point_tip = tipPoints_normal_sorted[0]\n')
    f.write('\tmax_point_tip = tipPoints_normal_sorted[1]\n')
    f.write('\ttipChordVector = [p2 - p1 for p1,p2 in zip(min_point_tip, max_point_tip)]\n')
    f.write('\tf.write(\'tip_chord_vector: \' + str(round(tipChordVector[0], 8)) + \' \' +str(round(tipChordVector[1], 8)) + \' \' + str(round(tipChordVector[2], 8)) + \'\\n\\n\')\n\n')


    f.write('fmrp = CreateOutputMRPFile()\n\n')


    f.write('control_surfaces = [\'canard\', \'strake\', \'fin\', \'tailfin\']\n')
    f.write('for i_enclosure in final_enclosures:\n')
    f.write('\ttry:\n')
    f.write('\t\tif len(i_enclosure) > 1:\n')
    f.write('\t\t\tmin_x = min_y = min_z = float(\'inf\')\n')
    f.write('\t\t\tmax_x = max_y = max_z = float(\'-inf\')\n')
    f.write('\t\t\tfor split in i_enclosure:\n')
    f.write('\t\t\t\tbox = split.Shape.GetBoundingBox(identity_matrix)\n')
    f.write('\t\t\t\tmin_x = min(min_x, box.MinCorner.X)\n')
    f.write('\t\t\t\tmin_y = min(min_y, box.MinCorner.Y)\n')
    f.write('\t\t\t\tmin_z = min(min_z, box.MinCorner.Z)\n')
    f.write('\t\t\t\tmax_x = max(max_x, box.MaxCorner.X)\n')
    f.write('\t\t\t\tmax_y = max(max_y, box.MaxCorner.Y)\n')
    f.write('\t\t\t\tmax_z = max(max_z, box.MaxCorner.Z)\n')
    f.write('\t\t\tlength_x = max_x - min_x\n')
    f.write('\t\t\tlength_y = max_y - min_y\n')
    f.write('\t\t\tlength_z = max_z - min_z\n')
    f.write('\texcept TypeError:\n')
    f.write('\t\tif any(i_name in i_enclosure.Name.ToLower() for i_name in control_surfaces):\n')
    f.write('\t\t\tCalculate_Control_Surface_MRP(fmrp, i_enclosure)\n\n')
    f.write('fmrp.close()\n')

  return(SC_FILE)

